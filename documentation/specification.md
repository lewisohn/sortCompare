**Specification** (M‰‰rittelydokumentti)

The purpose of this project will be to implement a variety of sorting algorithms and then compare their running time and memory requirements in various situations.

I have chosen six sorting algorithms that vary significantly from one another to make the comparisons more interesting. These algorithms are listed below with their sorting method in brackets:

- Bubble sort (exchanging)
- Insertion sort (insertion)
- Merge sort (merging)
- Quicksort (partitioning)
- Heapsort (selection)
- Bucket sort (non-comparative)

I'll also be implementing a flexible-size array roughly equivalent to Java's ArrayList.

Upon running the program, the user will first be asked to provide some non-negative integers to sort. These can be entered manually or generated by the program. A combination of the two will also be possible, so the user could, for example, choose to generate some random integers between 0 and 100, followed by consecutive integers from 1 to 5, and then manually add an outlier such as 1000, to get a list that ultimately looks like this:

41, 94, 20, 59, 88, 6, 18, 56, 66, 78, 1, 2, 3, 4, 5, 1000

Once the user is satisfied with their input, they will be able to choose which algorithms they wish to evaluate (at least one, and at most all of them) and whether they want to compare their running times or memory requirements. The program will then output the results.

In theory, the algorithms should have the following worst-case complexities in Big-O notation:

- Bubble sort: time O(n^2), space O(1)
- Insertion sort: time O(n^2), space O(1)
- Merge sort: time O(n log(n)), space O(n)
- Quicksort: time O(n^2), space O(log(n))
- Heapsort: time O(n log(n)), space O(1)
- Bucket sort: time O(n^2), space O(n)

Source: [Big-O Cheat Sheet](http://bigocheatsheet.com/)

I'll also be interested in each algorithm's best-case and average complexities so I'll be running the program myself extensively and compiling a report.