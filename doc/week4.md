**Week 4 report** (Viikkoraportti 4)

I implemented the remaining sorting algorithms this week, Quick and Bucket. They proved to be the most difficult to implement. In fact, in the course of trying to write a bucket sort, I inadvertently wrote something called counting sort, which is just a bucket sort with bucket size 1. While counting sort is very efficient in certain situations, its worst-case space complexity is too big to pass about half of the JUnit tests I set up for all my sorting algorithms. I'm not going to include it in my final program but I decided to leave the code in the project rather than deleting it altogether. In order to come up with a more efficient bucket sort that *could* pass those tests, I had to provide bucket sort with an inner sorting algorithm to sort the buckets. I played around with merge and heap sorts but after implementing quicksort I saw just how quick it is, so I switched to that. An idea I've had for the future is to allow the end user to select which inner sorting algorithm their instance of the Bucket class uses.

I also started working on my CustomList class, which is effectively a replacement of Java's ArrayList. Since it's a work-in-progress which still needs testing, the project currently contains the existing CustomList which extends ArrayList and the new CustomListPrototype class. This is because the first code review is coming up and I want the program to actually work for whoever reviews my code. I decided to ditch my CustomHeap class (which previously extended Java's PriorityQueue) because it was only used in one place - the heap sort algorithm - so it made more sense to build the heap there directly. Finally, the tests have been improved slightly and there have been a few other minor changes.

It's pretty clear what needs to be done next: finish up CustomList and its tests then write an automated evaluator. I also need to find out how to properly measure memory usage since my current results don't seem accurate - Bubble always has the highest memory usage despite being an in-place sort, which I suspect is simply because it runs first.